{% extends "base.html" %}

{% block title %}Patterns - CryptoLens{% endblock %}

{% block content %}
<div x-data="patternsPage()" class="space-y-6">
    <!-- Page Header with Tabs -->
    <div class="flex items-center justify-between flex-wrap gap-4">
        <div class="flex items-center space-x-6">
            <h1 class="text-2xl font-bold">Patterns & Signals</h1>
            <!-- Tabs -->
            <div class="flex space-x-1 bg-gray-800 rounded-lg p-1">
                <button @click="activeTab = 'patterns'"
                        :class="activeTab === 'patterns' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'"
                        class="px-4 py-2 rounded-md text-sm font-medium transition">
                    Patterns
                </button>
                <button @click="activeTab = 'signals'; loadSignals()"
                        :class="activeTab === 'signals' ? 'bg-blue-600 text-white' : 'text-gray-400 hover:text-white'"
                        class="px-4 py-2 rounded-md text-sm font-medium transition">
                    Signals
                </button>
            </div>
        </div>
    </div>

    <!-- PATTERNS TAB -->
    <div x-show="activeTab === 'patterns'" x-data="patternChart()">
        <!-- Patterns Filters -->
        <div class="flex items-center justify-end mb-4">
            <form method="GET" class="flex items-center space-x-4" id="patternFilters">
            <!-- Hidden field to preserve status when using dropdowns -->
            <input type="hidden" name="status" value="{{ current_status or 'active' }}" id="statusHidden">

            <select name="symbol" onchange="this.form.submit()" class="bg-gray-800 border border-gray-700 rounded px-3 py-2 text-sm">
                <option value="">All Symbols</option>
                {% for s in symbols %}
                <option value="{{ s.symbol }}" {% if current_symbol == s.symbol %}selected{% endif %}>
                    {{ s.symbol }}
                </option>
                {% endfor %}
            </select>

            <select name="timeframe" onchange="this.form.submit()" class="bg-gray-800 border border-gray-700 rounded px-3 py-2 text-sm">
                <option value="">All Timeframes</option>
                {% for tf in timeframes %}
                <option value="{{ tf }}" {% if current_timeframe == tf %}selected{% endif %}>{{ tf }}</option>
                {% endfor %}
            </select>

            <!-- Status toggle buttons -->
            <div class="flex rounded-lg overflow-hidden border border-gray-700">
                <button type="submit" name="status" value="active" onclick="document.getElementById('statusHidden').disabled=true"
                        class="px-3 py-2 text-sm {% if current_status == 'active' %}bg-blue-600 text-white{% else %}bg-gray-800 text-gray-300 hover:bg-gray-700{% endif %}">
                    Active
                </button>
                <button type="submit" name="status" value="" onclick="document.getElementById('statusHidden').disabled=true"
                        class="px-3 py-2 text-sm border-l border-gray-700 {% if not current_status %}bg-blue-600 text-white{% else %}bg-gray-800 text-gray-300 hover:bg-gray-700{% endif %}">
                    All
                </button>
                <button type="submit" name="status" value="expired" onclick="document.getElementById('statusHidden').disabled=true"
                        class="px-3 py-2 text-sm border-l border-gray-700 {% if current_status == 'expired' %}bg-blue-600 text-white{% else %}bg-gray-800 text-gray-300 hover:bg-gray-700{% endif %}">
                    Expired
                </button>
                <button type="submit" name="status" value="filled" onclick="document.getElementById('statusHidden').disabled=true"
                        class="px-3 py-2 text-sm border-l border-gray-700 {% if current_status == 'filled' %}bg-blue-600 text-white{% else %}bg-gray-800 text-gray-300 hover:bg-gray-700{% endif %}">
                    Filled
                </button>
            </div>
        </form>
    </div>

    <!-- Chart Container -->
    {% if current_symbol %}
    <div class="bg-card rounded-lg p-4" x-ref="chartContainer">
        <div class="flex items-center justify-between mb-4">
            <div class="flex items-center space-x-4">
                <h2 class="text-lg font-bold">{{ current_symbol }} - {{ current_timeframe or '1h' }}</h2>
                <button x-show="selectedPatternIds.length > 0" @click="clearAllSelections()"
                        class="px-3 py-1 rounded text-sm bg-gray-700 hover:bg-gray-600 transition-colors">
                    Clear
                </button>
                <span x-show="selectedPatternIds.length === 0" class="text-sm text-muted">
                    Click a pattern below to show levels
                </span>
                <!-- Legend when pattern selected -->
                <div x-show="selectedPatternIds.length > 0" class="flex items-center space-x-3 text-xs">
                    <span class="flex items-center"><span class="w-3 h-0.5 bg-green-500 mr-1"></span><span class="w-3 h-0.5 bg-red-500 mr-1"></span>Zone</span>
                    <span class="flex items-center"><span class="w-3 h-0.5 bg-blue-500 mr-1 border-dashed"></span>Entry</span>
                    <span class="flex items-center"><span class="w-3 h-0.5 bg-red-400 mr-1"></span>SL</span>
                    <span class="flex items-center"><span class="w-3 h-0.5 bg-green-400 mr-1"></span>TP1</span>
                    <span class="flex items-center"><span class="w-3 h-0.5 bg-green-500 mr-1"></span>TP2</span>
                </div>
            </div>
            <div class="flex space-x-2">
                {% for tf in timeframes %}
                <a href="?symbol={{ current_symbol }}&timeframe={{ tf }}&status={{ current_status }}"
                   class="px-3 py-1 rounded text-sm {% if current_timeframe == tf %}bg-blue-600{% else %}bg-gray-700 hover:bg-gray-600{% endif %}">
                    {{ tf }}
                </a>
                {% endfor %}
            </div>
        </div>
        <div id="chart" style="height: 400px;"></div>
    </div>
    {% endif %}

    <!-- Patterns List -->
    <div class="bg-card rounded-lg overflow-hidden">
        <table class="w-full">
            <thead>
                <tr class="border-b border-gray-700 bg-gray-800/50">
                    <th class="text-left p-3 text-muted font-medium">Symbol</th>
                    <th class="text-left p-3 text-muted font-medium">Price</th>
                    <th class="text-left p-3 text-muted font-medium">TF</th>
                    <th class="text-left p-3 text-muted font-medium">Type</th>
                    <th class="text-left p-3 text-muted font-medium">Direction</th>
                    <th class="text-left p-3 text-muted font-medium">Zone</th>
                    <th class="text-left p-3 text-muted font-medium">Entry</th>
                    <th class="text-left p-3 text-muted font-medium">SL / TP</th>
                    <th class="text-left p-3 text-muted font-medium">Status</th>
                    <th class="text-left p-3 text-muted font-medium">Expires</th>
                    <th class="text-left p-3 text-muted font-medium"></th>
                </tr>
            </thead>
            <tbody>
                {% for pattern in patterns %}
                <tr class="border-b border-gray-800 hover:bg-gray-800/50 cursor-pointer {% if pattern.is_expired %}opacity-60{% endif %}"
                    :class="{ 'ring-2 ring-blue-500 bg-blue-900/30': isPatternSelected({{ pattern.id }}) }"
                    @click="togglePattern({{ pattern.id }}, {{ pattern.zone_low }}, {{ pattern.zone_high }}, '{{ pattern.direction }}', {{ pattern.trading_levels.entry }}, {{ pattern.trading_levels.stop_loss }}, {{ pattern.trading_levels.take_profit_1 }}, {{ pattern.trading_levels.take_profit_2 }}, {{ pattern.detected_at }})"
                >
                    <td class="p-3">
                        <a href="?symbol={{ pattern.symbol.symbol }}&timeframe={{ pattern.timeframe }}"
                           class="hover:text-blue-400 font-medium">
                            {{ pattern.symbol.symbol }}
                        </a>
                    </td>
                    <td class="p-3 font-mono text-xs">
                        {% if pattern.current_price %}
                            ${{ pattern.current_price|price }}
                        {% else %}
                            <span class="text-muted">-</span>
                        {% endif %}
                    </td>
                    <td class="p-3 text-muted">{{ pattern.timeframe }}</td>
                    <td class="p-3">
                        {% if pattern.pattern_type == 'imbalance' %}
                            <span class="px-2 py-1 rounded text-xs bg-purple-900 text-purple-200">FVG</span>
                        {% elif pattern.pattern_type == 'order_block' %}
                            <span class="px-2 py-1 rounded text-xs bg-orange-900 text-orange-200">OB</span>
                        {% elif pattern.pattern_type == 'liquidity_sweep' %}
                            <span class="px-2 py-1 rounded text-xs bg-cyan-900 text-cyan-200">Sweep</span>
                        {% else %}
                            <span class="px-2 py-1 rounded text-xs bg-gray-700">{{ pattern.pattern_type }}</span>
                        {% endif %}
                    </td>
                    <td class="p-3">
                        <span class="{% if pattern.direction == 'bullish' %}bullish{% else %}bearish{% endif %} font-medium text-sm">
                            {% if pattern.direction == 'bullish' %}ðŸŸ¢{% else %}ðŸ”´{% endif %}
                        </span>
                    </td>
                    <td class="p-3 font-mono text-xs">
                        {{ pattern.zone_low|price }}-{{ pattern.zone_high|price }}
                    </td>
                    <td class="p-3 font-mono text-xs {% if pattern.direction == 'bullish' %}text-green-400{% else %}text-red-400{% endif %}">
                        {{ pattern.trading_levels.entry|price }}
                    </td>
                    <td class="p-3 font-mono text-xs">
                        <span class="text-red-500">{{ pattern.trading_levels.stop_loss|price }}</span>
                        <span class="text-muted">/</span>
                        <span class="text-green-500">{{ pattern.trading_levels.take_profit_2|price }}</span>
                        <span class="text-muted">({{ pattern.trading_levels.risk_reward_2 }}R)</span>
                    </td>
                    <td class="p-3">
                        <span class="px-2 py-1 rounded text-xs
                            {% if pattern.status == 'active' and not pattern.is_expired %}bg-blue-900 text-blue-200
                            {% elif pattern.status == 'filled' %}bg-green-900 text-green-200
                            {% elif pattern.status == 'expired' or pattern.is_expired %}bg-gray-700 text-gray-400
                            {% else %}bg-gray-700{% endif %}">
                            {% if pattern.is_expired and pattern.status == 'active' %}expired{% else %}{{ pattern.status }}{% endif %}
                        </span>
                        {% if pattern.fill_percentage and pattern.fill_percentage > 0 %}
                        <span class="text-xs text-muted ml-1">{{ '%.0f'|format(pattern.fill_percentage) }}%</span>
                        {% endif %}
                    </td>
                    <td class="p-3 text-xs">
                        {% if pattern.status == 'active' and not pattern.is_expired %}
                            <span class="{% if pattern.time_remaining.startswith('0h') or pattern.time_remaining.startswith('1h') %}text-red-400{% elif 'h' in pattern.time_remaining and pattern.time_remaining.split('h')[0]|int < 6 %}text-yellow-400{% else %}text-muted{% endif %}">
                                {{ pattern.time_remaining }}
                            </span>
                        {% elif pattern.is_expired %}
                            <span class="text-gray-500">Expired</span>
                        {% else %}
                            <span class="text-gray-500">-</span>
                        {% endif %}
                    </td>
                    <td class="p-3">
                        {% if pattern.status == 'active' and not pattern.is_expired %}
                        <button onclick="createTradeFromPattern({{ pattern.id }})"
                                class="px-2 py-1 text-xs bg-green-700 hover:bg-green-600 rounded">
                            Trade
                        </button>
                        {% endif %}
                    </td>
                </tr>
                {% else %}
                <tr>
                    <td colspan="11" class="p-8 text-center text-muted">
                        No patterns found. Run a scan to detect patterns.
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>

    <!-- Pagination -->
    {% if pagination and pagination.pages > 1 %}
    <div class="flex items-center justify-between mt-4">
        <div class="text-sm text-muted">
            Showing {{ ((pagination.page - 1) * pagination.per_page) + 1 }}-{{ [pagination.page * pagination.per_page, pagination.total] | min }} of {{ pagination.total }} patterns
        </div>
        <div class="flex items-center space-x-2">
            {% if pagination.has_prev %}
            <a href="?{% if current_symbol %}symbol={{ current_symbol }}&{% endif %}{% if current_timeframe %}timeframe={{ current_timeframe }}&{% endif %}{% if current_status %}status={{ current_status }}&{% endif %}page={{ pagination.prev_num }}"
               class="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-sm">
                Previous
            </a>
            {% endif %}

            {% for page_num in pagination.iter_pages(left_edge=1, left_current=2, right_current=2, right_edge=1) %}
                {% if page_num %}
                    {% if page_num == pagination.page %}
                    <span class="px-3 py-1 rounded bg-blue-600 text-sm">{{ page_num }}</span>
                    {% else %}
                    <a href="?{% if current_symbol %}symbol={{ current_symbol }}&{% endif %}{% if current_timeframe %}timeframe={{ current_timeframe }}&{% endif %}{% if current_status %}status={{ current_status }}&{% endif %}page={{ page_num }}"
                       class="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-sm">
                        {{ page_num }}
                    </a>
                    {% endif %}
                {% else %}
                    <span class="px-2 text-muted">...</span>
                {% endif %}
            {% endfor %}

            {% if pagination.has_next %}
            <a href="?{% if current_symbol %}symbol={{ current_symbol }}&{% endif %}{% if current_timeframe %}timeframe={{ current_timeframe }}&{% endif %}{% if current_status %}status={{ current_status }}&{% endif %}page={{ pagination.next_num }}"
               class="px-3 py-1 rounded bg-gray-700 hover:bg-gray-600 text-sm">
                Next
            </a>
            {% endif %}
        </div>
    </div>
    {% endif %}
    </div><!-- End patterns tab -->

    <!-- SIGNALS TAB -->
    <div x-show="activeTab === 'signals'" x-cloak>
        <!-- Signals Filters -->
        <div class="flex items-center justify-between mb-4">
            <div class="flex items-center space-x-2">
                <button @click="signalDirection = ''; loadSignals()"
                        :class="signalDirection === '' ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'"
                        class="px-4 py-2 rounded text-sm transition">All</button>
                <button @click="signalDirection = 'long'; loadSignals()"
                        :class="signalDirection === 'long' ? 'bg-green-600' : 'bg-gray-700 hover:bg-gray-600'"
                        class="px-4 py-2 rounded text-sm transition">Long</button>
                <button @click="signalDirection = 'short'; loadSignals()"
                        :class="signalDirection === 'short' ? 'bg-red-600' : 'bg-gray-700 hover:bg-gray-600'"
                        class="px-4 py-2 rounded text-sm transition">Short</button>
            </div>
            <div class="text-sm text-muted" x-show="signals.length > 0">
                <span x-text="signals.length"></span> signals found
            </div>
        </div>

        <!-- Signals Loading State -->
        <div x-show="signalsLoading" class="text-center py-12">
            <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
            <p class="text-muted mt-2">Loading signals...</p>
        </div>

        <!-- Signals Grid -->
        <div x-show="!signalsLoading" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <template x-for="signal in signals" :key="signal.id">
                <div class="bg-card rounded-lg p-4 border-l-4"
                     :class="signal.direction === 'long' ? 'border-green-500' : 'border-red-500'">
                    <div class="flex items-center justify-between mb-3">
                        <div>
                            <span class="font-bold text-lg" x-text="signal.symbol"></span>
                            <span x-show="signal.pattern_type" class="ml-2 px-2 py-0.5 rounded text-xs bg-gray-700"
                                  x-text="signal.pattern_type"></span>
                        </div>
                        <span class="font-bold text-lg"
                              :class="signal.direction === 'long' ? 'text-green-500' : 'text-red-500'"
                              x-text="signal.direction === 'long' ? 'LONG' : 'SHORT'"></span>
                    </div>

                    <div class="space-y-2 text-sm">
                        <div class="flex justify-between">
                            <span class="text-muted">Entry:</span>
                            <span class="font-mono" x-text="'$' + formatPrice(signal.entry_price)"></span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-muted">Stop Loss:</span>
                            <span class="font-mono text-red-400" x-text="'$' + formatPrice(signal.stop_loss)"></span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-muted">TP1 (1:1):</span>
                            <span class="font-mono text-green-400" x-text="'$' + formatPrice(signal.take_profit_1)"></span>
                        </div>
                        <div class="flex justify-between" x-show="signal.take_profit_2">
                            <span class="text-muted">TP2 (1:2):</span>
                            <span class="font-mono text-green-400" x-text="'$' + formatPrice(signal.take_profit_2)"></span>
                        </div>
                    </div>

                    <div class="mt-4 pt-3 border-t border-gray-700">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center space-x-2">
                                <span class="text-muted text-xs">TFs aligned:</span>
                                <span class="font-bold text-sm" x-text="signal.confluence_score"></span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-xs text-muted" x-text="signal.created_at"></span>
                            <span class="px-2 py-1 rounded text-xs"
                                  :class="{
                                      'bg-green-900 text-green-200': signal.status === 'notified',
                                      'bg-blue-900 text-blue-200': signal.status === 'filled',
                                      'bg-red-900 text-red-200': signal.status === 'stopped',
                                      'bg-gray-700': !['notified', 'filled', 'stopped'].includes(signal.status)
                                  }"
                                  x-text="signal.status"></span>
                        </div>
                    </div>
                </div>
            </template>

            <!-- Empty State -->
            <div x-show="signals.length === 0 && !signalsLoading" class="col-span-full text-center py-12 text-muted">
                <p class="text-lg mb-2">No signals found</p>
                <p class="text-sm">Signals are generated when patterns align across multiple timeframes.</p>
            </div>
        </div>
    </div><!-- End signals tab -->
</div>
{% endblock %}

{% block extra_js %}
<script>
// Main page controller for tabs
function patternsPage() {
    return {
        activeTab: 'patterns',
        signals: [],
        signalsLoading: false,
        signalDirection: '',

        async loadSignals() {
            this.signalsLoading = true;
            try {
                let url = '/api/signals';
                if (this.signalDirection) {
                    url += '?direction=' + this.signalDirection;
                }
                const response = await fetch(url);
                const data = await response.json();
                // API returns array directly, not {signals: [...]}
                this.signals = Array.isArray(data) ? data : (data.signals || []);
            } catch (e) {
                console.error('Failed to load signals:', e);
                this.signals = [];
            }
            this.signalsLoading = false;
        },

        formatPrice(price) {
            if (!price) return '-';
            if (price >= 1000) return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            if (price >= 1) return price.toFixed(2);
            return price.toFixed(6);
        }
    };
}

async function createTradeFromPattern(patternId) {
    try {
        const response = await fetch('/portfolio/api/trade-from-pattern', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken()
            },
            body: JSON.stringify({ pattern_id: patternId })
        });
        const data = await response.json();
        if (data.success) {
            window.location.href = data.redirect_url;
        } else {
            alert('Error: ' + (data.error || 'Failed to create trade'));
        }
    } catch (e) {
        alert('Error: ' + e.message);
    }
}

function patternChart() {
    return {
        selectedPatternIds: [],  // Array for multi-select
        selectedPatterns: {},    // Store pattern data by ID
        chart: null,
        candlestickSeries: null,
        patternSeries: [],
        priceLines: [],          // Store price line references for cleanup
        chartData: null,
        precision: 2,

        togglePattern(id, zoneLow, zoneHigh, direction, entry, sl, tp1, tp2, detectedAt) {
            const idx = this.selectedPatternIds.indexOf(id);
            if (idx > -1) {
                // Deselect
                this.selectedPatternIds.splice(idx, 1);
                delete this.selectedPatterns[id];
            } else {
                // Select
                this.selectedPatternIds.push(id);
                this.selectedPatterns[id] = { id, zoneLow, zoneHigh, direction, entry, sl, tp1, tp2, detectedAt };
            }
            this.drawSelectedPatterns();
        },

        isPatternSelected(id) {
            return this.selectedPatternIds.includes(id);
        },

        clearAllSelections() {
            this.selectedPatternIds = [];
            this.selectedPatterns = {};
            this.clearPatternSeries();
        },

        showAllPatterns() {
            this.clearAllSelections();
            this.drawAllPatterns();
        },

        clearPatternSeries() {
            // Remove line series
            this.patternSeries.forEach(series => {
                try { this.chart.removeSeries(series); } catch(e) {}
            });
            this.patternSeries = [];

            // Remove price lines from candlestick series
            this.priceLines.forEach(priceLine => {
                try { this.candlestickSeries.removePriceLine(priceLine); } catch(e) {}
            });
            this.priceLines = [];

            // Clear markers
            this.candlestickSeries.setMarkers([]);
        },

        drawSinglePattern(pattern) {
            if (!this.chart || !this.chartData) return;
            this.clearPatternSeries();

            const { zoneLow, zoneHigh, direction, entry, sl, tp1, tp2, detectedAt } = pattern;
            const lineColor = direction === 'bullish' ? '#22c55e' : '#ef4444';
            const candles = this.chartData.candles;
            const firstTime = candles[0].timestamp / 1000;
            const lastTime = candles[candles.length - 1].timestamp / 1000;
            const patternStartTime = detectedAt / 1000;
            const visibleStartTime = Math.max(patternStartTime, firstTime);

            const priceFormat = {
                type: 'price',
                precision: this.precision,
                minMove: Math.pow(10, -this.precision),
            };

            // Zone high line
            const highLine = this.chart.addLineSeries({
                color: lineColor,
                lineWidth: 2,
                priceLineVisible: false,
                lastValueVisible: true,
                crosshairMarkerVisible: false,
                priceFormat
            });
            highLine.setData([
                { time: visibleStartTime, value: zoneHigh },
                { time: lastTime, value: zoneHigh }
            ]);
            this.patternSeries.push(highLine);

            // Zone low line
            const lowLine = this.chart.addLineSeries({
                color: lineColor,
                lineWidth: 2,
                priceLineVisible: false,
                lastValueVisible: true,
                crosshairMarkerVisible: false,
                priceFormat
            });
            lowLine.setData([
                { time: visibleStartTime, value: zoneLow },
                { time: lastTime, value: zoneLow }
            ]);
            this.patternSeries.push(lowLine);

            // Entry line (dashed)
            const entryLine = this.chart.addLineSeries({
                color: '#3b82f6',
                lineWidth: 1,
                lineStyle: 2, // Dashed
                priceLineVisible: false,
                lastValueVisible: true,
                crosshairMarkerVisible: false,
                priceFormat
            });
            entryLine.setData([
                { time: visibleStartTime, value: entry },
                { time: lastTime, value: entry }
            ]);
            this.patternSeries.push(entryLine);

            // Stop Loss area (red transparent)
            const slArea = this.chart.addAreaSeries({
                topColor: 'rgba(239, 68, 68, 0.3)',
                bottomColor: 'rgba(239, 68, 68, 0.1)',
                lineColor: 'rgba(239, 68, 68, 0.8)',
                lineWidth: 1,
                priceLineVisible: false,
                lastValueVisible: true,
                crosshairMarkerVisible: false,
                priceFormat
            });
            slArea.setData([
                { time: visibleStartTime, value: sl },
                { time: lastTime, value: sl }
            ]);
            this.patternSeries.push(slArea);

            // Take Profit 1 area (light green transparent)
            const tp1Area = this.chart.addAreaSeries({
                topColor: 'rgba(34, 197, 94, 0.2)',
                bottomColor: 'rgba(34, 197, 94, 0.05)',
                lineColor: 'rgba(34, 197, 94, 0.6)',
                lineWidth: 1,
                lineStyle: 2,
                priceLineVisible: false,
                lastValueVisible: true,
                crosshairMarkerVisible: false,
                priceFormat
            });
            tp1Area.setData([
                { time: visibleStartTime, value: tp1 },
                { time: lastTime, value: tp1 }
            ]);
            this.patternSeries.push(tp1Area);

            // Take Profit 2 area (green transparent)
            const tp2Area = this.chart.addAreaSeries({
                topColor: 'rgba(34, 197, 94, 0.3)',
                bottomColor: 'rgba(34, 197, 94, 0.1)',
                lineColor: 'rgba(34, 197, 94, 0.8)',
                lineWidth: 1,
                priceLineVisible: false,
                lastValueVisible: true,
                crosshairMarkerVisible: false,
                priceFormat
            });
            tp2Area.setData([
                { time: visibleStartTime, value: tp2 },
                { time: lastTime, value: tp2 }
            ]);
            this.patternSeries.push(tp2Area);

            // Add marker
            if (patternStartTime >= firstTime && patternStartTime <= lastTime) {
                this.candlestickSeries.setMarkers([{
                    time: patternStartTime,
                    position: direction === 'bullish' ? 'belowBar' : 'aboveBar',
                    color: lineColor,
                    shape: direction === 'bullish' ? 'arrowUp' : 'arrowDown',
                    text: 'Pattern'
                }]);
            }
        },

        drawSelectedPatterns() {
            if (!this.chart || !this.chartData) return;
            this.clearPatternSeries();

            if (this.selectedPatternIds.length === 0) return;

            const candles = this.chartData.candles;
            const firstTime = candles[0].timestamp / 1000;
            const lastTime = candles[candles.length - 1].timestamp / 1000;
            const markers = [];

            const priceFormat = {
                type: 'price',
                precision: this.precision,
                minMove: Math.pow(10, -this.precision),
            };

            // Helper to create price line with label on right axis
            const createPriceLine = (series, price, color, title) => {
                series.createPriceLine({
                    price: price,
                    color: color,
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    axisLabelVisible: true,
                    title: title,
                });
            };

            // Draw each selected pattern
            Object.values(this.selectedPatterns).forEach(pattern => {
                const { zoneLow, zoneHigh, direction, entry, sl, tp1, tp2, detectedAt } = pattern;
                const zoneColor = direction === 'bullish' ? '#22c55e' : '#ef4444';
                const patternStartTime = detectedAt / 1000;

                // Use price lines on the candlestick series for clean display on right axis
                // Zone High
                this.priceLines.push(this.candlestickSeries.createPriceLine({
                    price: zoneHigh,
                    color: zoneColor,
                    lineWidth: 2,
                    lineStyle: 0, // Solid
                    axisLabelVisible: true,
                    title: 'Zone H',
                }));

                // Zone Low
                this.priceLines.push(this.candlestickSeries.createPriceLine({
                    price: zoneLow,
                    color: zoneColor,
                    lineWidth: 2,
                    lineStyle: 0, // Solid
                    axisLabelVisible: true,
                    title: 'Zone L',
                }));

                // Entry (blue dashed)
                this.priceLines.push(this.candlestickSeries.createPriceLine({
                    price: entry,
                    color: '#3b82f6',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    axisLabelVisible: true,
                    title: 'Entry',
                }));

                // Stop Loss (red)
                this.priceLines.push(this.candlestickSeries.createPriceLine({
                    price: sl,
                    color: '#f87171',
                    lineWidth: 1,
                    lineStyle: 2,
                    axisLabelVisible: true,
                    title: 'SL',
                }));

                // TP1 (light green)
                if (tp1) {
                    this.priceLines.push(this.candlestickSeries.createPriceLine({
                        price: tp1,
                        color: '#4ade80',
                        lineWidth: 1,
                        lineStyle: 2,
                        axisLabelVisible: true,
                        title: 'TP1',
                    }));
                }

                // TP2 (green)
                if (tp2) {
                    this.priceLines.push(this.candlestickSeries.createPriceLine({
                        price: tp2,
                        color: '#22c55e',
                        lineWidth: 1,
                        lineStyle: 2,
                        axisLabelVisible: true,
                        title: 'TP2',
                    }));
                }

                // Add marker at pattern detection time
                if (patternStartTime >= firstTime && patternStartTime <= lastTime) {
                    markers.push({
                        time: patternStartTime,
                        position: direction === 'bullish' ? 'belowBar' : 'aboveBar',
                        color: zoneColor,
                        shape: direction === 'bullish' ? 'arrowUp' : 'arrowDown',
                        text: ''
                    });
                }
            });

            // Set all markers
            if (markers.length > 0) {
                markers.sort((a, b) => a.time - b.time);
                this.candlestickSeries.setMarkers(markers);
            }
        },

        drawAllPatterns() {
            if (!this.chart || !this.chartData) return;
            this.clearPatternSeries();

            const candles = this.chartData.candles;
            const firstTime = candles[0].timestamp / 1000;
            const lastTime = candles[candles.length - 1].timestamp / 1000;
            const markers = [];

            const priceFormat = {
                type: 'price',
                precision: this.precision,
                minMove: Math.pow(10, -this.precision),
            };

            this.chartData.patterns.forEach(pattern => {
                const lineColor = pattern.direction === 'bullish' ? '#22c55e' : '#ef4444';
                const patternStartTime = pattern.detected_at / 1000;
                const visibleStartTime = Math.max(patternStartTime, firstTime);

                if (patternStartTime <= lastTime) {
                    // Zone high
                    const highLine = this.chart.addLineSeries({
                        color: lineColor,
                        lineWidth: 2,
                        priceLineVisible: false,
                        lastValueVisible: true,
                        crosshairMarkerVisible: false,
                        priceFormat
                    });
                    highLine.setData([
                        { time: visibleStartTime, value: pattern.zone_high },
                        { time: lastTime, value: pattern.zone_high }
                    ]);
                    this.patternSeries.push(highLine);

                    // Zone low
                    const lowLine = this.chart.addLineSeries({
                        color: lineColor,
                        lineWidth: 2,
                        priceLineVisible: false,
                        lastValueVisible: true,
                        crosshairMarkerVisible: false,
                        priceFormat
                    });
                    lowLine.setData([
                        { time: visibleStartTime, value: pattern.zone_low },
                        { time: lastTime, value: pattern.zone_low }
                    ]);
                    this.patternSeries.push(lowLine);

                    // Marker
                    if (patternStartTime >= firstTime && patternStartTime <= lastTime) {
                        const label = pattern.pattern_type === 'imbalance' ? 'FVG' :
                                     pattern.pattern_type === 'order_block' ? 'OB' : 'Sweep';
                        markers.push({
                            time: patternStartTime,
                            position: pattern.direction === 'bullish' ? 'belowBar' : 'aboveBar',
                            color: lineColor,
                            shape: pattern.direction === 'bullish' ? 'arrowUp' : 'arrowDown',
                            text: label
                        });
                    }
                }
            });

            if (markers.length > 0) {
                markers.sort((a, b) => a.time - b.time);
                this.candlestickSeries.setMarkers(markers);
            }
        }
    };
}
</script>
{% if current_symbol %}
<script>
document.addEventListener('DOMContentLoaded', async function() {
    const chartContainer = document.getElementById('chart');
    const timeframe = '{{ current_timeframe or "1h" }}';

    function getPricePrecision(price) {
        if (price < 0.0001) return 8;
        if (price < 0.01) return 6;
        if (price < 1) return 4;
        if (price < 100) return 3;
        if (price < 10000) return 2;
        return 0;
    }

    const chart = LightweightCharts.createChart(chartContainer, {
        layout: {
            background: { color: '#242424' },
            textColor: '#DDD',
        },
        grid: {
            vertLines: { color: '#333' },
            horzLines: { color: '#333' },
        },
        width: chartContainer.clientWidth,
        height: 400,
        timeScale: {
            timeVisible: true,
            secondsVisible: timeframe === '1m',
            borderColor: '#555',
            tickMarkFormatter: (time) => {
                const date = new Date(time * 1000);
                if (['1d', '1w'].includes(timeframe)) {
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                } else if (['4h', '1h'].includes(timeframe)) {
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) +
                           ' ' + date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                } else {
                    return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                }
            }
        },
        rightPriceScale: { borderColor: '#555' },
        crosshair: { mode: 0 },
    });

    const candlestickSeries = chart.addCandlestickSeries({
        upColor: '#22c55e',
        downColor: '#ef4444',
        borderUpColor: '#22c55e',
        borderDownColor: '#ef4444',
        wickUpColor: '#22c55e',
        wickDownColor: '#ef4444',
    });

    const symbol = '{{ current_symbol }}'.replace('/', '-');

    // State for lazy loading
    let allCandles = [];  // All loaded candles (raw data)
    let hasMore = false;
    let isLoadingMore = false;
    let oldestTimestamp = null;
    const MAX_CANDLES = Infinity;  // No limit (use a number like 2000 to limit for performance)

    // Function to load more historical candles
    async function loadMoreCandles() {
        if (!hasMore || isLoadingMore || !oldestTimestamp) return;
        if (allCandles.length >= MAX_CANDLES) {
            console.log(`Max candles reached (${MAX_CANDLES})`);
            hasMore = false;
            return;
        }

        isLoadingMore = true;
        try {
            const response = await fetch(`/patterns/chart/${symbol}/${timeframe}?before=${oldestTimestamp}`);
            const data = await response.json();

            if (data.candles && data.candles.length > 0) {
                // Prepend new candles to existing data
                allCandles = [...data.candles, ...allCandles];
                oldestTimestamp = data.candles[0].timestamp;
                hasMore = data.has_more;

                // Update chart with all candles
                const chartCandles = allCandles.map(c => ({
                    time: c.timestamp / 1000,
                    open: c.open,
                    high: c.high,
                    low: c.low,
                    close: c.close,
                }));
                candlestickSeries.setData(chartCandles);

                // Update Alpine component data (patternChart, not patternsPage)
                const patternTabEl = document.querySelector('[x-data="patternChart()"]');
                if (patternTabEl) {
                    const alpineComponent = Alpine.$data(patternTabEl);
                    if (alpineComponent.chartData) {
                        alpineComponent.chartData.candles = allCandles;
                    }
                }

                console.log(`Loaded ${data.candles.length} more candles (total: ${allCandles.length})`);
            } else {
                hasMore = false;
            }
        } catch (e) {
            console.error('Failed to load more candles:', e);
        } finally {
            isLoadingMore = false;
        }
    }

    try {
        const response = await fetch(`/patterns/chart/${symbol}/${timeframe}`);
        const data = await response.json();

        if (data.candles && data.candles.length > 0) {
            allCandles = data.candles;
            hasMore = data.has_more;
            oldestTimestamp = data.candles[0].timestamp;

            const candles = data.candles.map(c => ({
                time: c.timestamp / 1000,
                open: c.open,
                high: c.high,
                low: c.low,
                close: c.close,
            }));
            candlestickSeries.setData(candles);

            const lastPrice = data.candles[data.candles.length - 1].close;
            const precision = getPricePrecision(lastPrice);
            candlestickSeries.applyOptions({
                priceFormat: {
                    type: 'price',
                    precision: precision,
                    minMove: Math.pow(10, -precision),
                }
            });

            // Store in Alpine component (patternChart, not patternsPage)
            // Find the element with patternChart() x-data
            const patternTabEl = document.querySelector('[x-data="patternChart()"]');
            if (patternTabEl) {
                const alpineComponent = Alpine.$data(patternTabEl);
                alpineComponent.chart = chart;
                alpineComponent.candlestickSeries = candlestickSeries;
                alpineComponent.chartData = data;
                alpineComponent.precision = precision;

                // Don't draw patterns by default - let user select which ones to see
                // alpineComponent.drawAllPatterns();
            }

            // Subscribe to visible range changes for lazy loading
            chart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
                if (!logicalRange || !hasMore || isLoadingMore) return;

                // Load more when user scrolls to show first 10% of data
                const threshold = Math.max(10, allCandles.length * 0.1);
                if (logicalRange.from < threshold) {
                    loadMoreCandles();
                }
            });
        }

        chart.timeScale().fitContent();
    } catch (e) {
        console.error('Failed to load chart data:', e);
    }

    window.addEventListener('resize', () => {
        chart.applyOptions({ width: chartContainer.clientWidth });
    });
});
</script>
{% endif %}
{% endblock %}
